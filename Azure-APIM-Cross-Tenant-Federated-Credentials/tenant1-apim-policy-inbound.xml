<policies>
    <inbound>
        <!-- Set backend URL and rewrite path -->
        <set-backend-service base-url="https://YOUR_TENANT2_APIM_NAME.azure-api.net" />
        <rewrite-uri template="/your-api-path/validate" copy-unmatched-params="true" />
        
        <!-- Step 1: Get assertion token from UAMI for the tenant1 multi-tenant app -->
        <send-request mode="new" response-variable-name="dummyResponse" timeout="20" ignore-error="true">
            <set-url>https://management.azure.com/</set-url>
            <set-method>GET</set-method>
            <authentication-managed-identity 
                resource="api://AzureADTokenExchange" 
                client-id="YOUR_UAMI_CLIENT_ID" 
                output-token-variable-name="assertionToken" />
        </send-request>
        
        <!-- Step 2: Exchange assertion token for tenant2 API token using federated credential -->
        <send-request mode="new" response-variable-name="finalTokenResponse" timeout="20" ignore-error="false">
            <set-url>https://login.microsoftonline.com/YOUR_TENANT2_ID/oauth2/v2.0/token</set-url>
            <set-method>POST</set-method>
            <set-header name="Content-Type" exists-action="override">
                <value>application/x-www-form-urlencoded</value>
            </set-header>
            <set-body>@{
                var bridgeAppId = "YOUR_BRIDGE_APP_ID";
                var tenant2ApiAppId = "YOUR_TENANT2_API_APPID";
                
                return $"grant_type=client_credentials&client_id={bridgeAppId}&scope={tenant2ApiAppId}/.default&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&client_assertion={(string)context.Variables["assertionToken"]}";
            }</set-body>
        </send-request>
        
        <!-- Step 3: Extract final token -->
        <set-variable name="finalTokenBody" value="@{
            return ((IResponse)context.Variables["finalTokenResponse"]).Body.As<string>();
        }" />
        <set-variable name="finalToken" value="@{
            return JObject.Parse((string)context.Variables["finalTokenBody"])["access_token"].ToString();
        }" />
        
        <!-- Step 4: Set Authorization header with the final token -->
        <set-header name="Authorization" exists-action="override">
            <value>@("Bearer " + (string)context.Variables["finalToken"])</value>
        </set-header>
    </inbound>
    <backend>
        <forward-request />
    </backend>
    <outbound>
        <set-header name="X-Debug-Backend-URL" exists-action="override">
            <value>@(context.Request.Url.ToString())</value>
        </set-header>
        <set-header name="X-Debug-Token-Exchange" exists-action="override">
            <value>Success</value>
        </set-header>
    </outbound>
    <on-error>
        <set-header name="X-Error-Message" exists-action="override">
            <value>@(context.LastError.Message)</value>
        </set-header>
        <set-header name="X-Error-Source" exists-action="override">
            <value>@(context.LastError.Source)</value>
        </set-header>
        <set-body>@{
            var errorDetails = new JObject(
                new JProperty("error", context.LastError.Message),
                new JProperty("source", context.LastError.Source),
                new JProperty("reason", context.LastError.Reason)
            );
            
            if (context.Variables.ContainsKey("assertionToken")) {
                var token = (string)context.Variables["assertionToken"];
                errorDetails.Add("assertionToken", token.Substring(0, Math.Min(100, token.Length)) + "...");
            }
            
            if (context.Variables.ContainsKey("finalTokenResponse")) {
                var finalResp = ((IResponse)context.Variables["finalTokenResponse"]).Body.As<string>();
                errorDetails.Add("finalTokenBody", finalResp);
            }
            
            return errorDetails.ToString();
        }</set-body>
    </on-error>
</policies>